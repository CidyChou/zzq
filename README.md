## 自走棋后端设计方案

### 概述
- 棋盘规则为 8* 8 个格子、每个格子只能占一个棋子
- 棋子规则
  1. 基础属性: 血量、攻击力、防御力、攻击速度、移动步数、攻击距离
  2. 攻击范围：以棋子为原点，攻击距离为半径画圆，圆内为攻击范围
- 公式：
  1. 战斗伤害 = 攻击力 - 防御力

### 寻路算法设计
#### 使用A star算法
1. **基本步骤**
- 将起点区域添加到open列表中，该区域有最小的和值。
- 重复以下：
    - 将open列表中最小F值的区域X移除，然后添加到close列表中。
    - 对于与X相邻的每一块可通行且不在close列表中的区域T：
        - 如果T不在open列表中：添加到open列表，把X设为T的前驱
        - 如果T已经在open列表中：检查 F 是否更小。如果是，更新 F 和前驱
  - 直到：
      - 终点添加到了close列表。（已找到路径）
      - 终点未添加到close列表且open列表已空。（未找到路径）

 2. A star Demo()     

### 战斗序列设计

#### 战斗状态图与有限状态机设计

![战斗状态图](https://github.com/CidyChou/Markdown/blob/master/Res/%E7%8A%B6%E6%80%81%E5%9B%BE.jpg?raw=true)

- 状态：
    - 待命
    - 移动
    - 攻击
    - 释放技能

- 事件(暂不考虑技能)：
    - 发现目标死亡
    - 发现目标在范围外
    - 发现目标在范围内

 [有限状态机Demo](fsm/main.go)

- 输出结果
            
            d:\go\src\dc-sz\dc\zzq\fsm>go run main.go
            - 初始状态 => 搜寻目标
            敌人在攻击范围以外 => 移动
            - 状态从 [ 寻找目标 ] 变成 [ 移动 ]
            敌人在攻击范围以内 => 攻击
            - 状态从 [ 移动 ] 变成 [ 攻击 ]
            目标已死亡 => 重新搜寻目标
            - 状态从 [ 攻击 ] 变成 [ 寻找目标 ]
            敌人在攻击范围以内 => 攻击
            - 状态从 [ 寻找目标 ] 变成 [ 攻击 ]  
          

#### 战斗序列

**假设：**
- 玩家A,棋子A属性： 攻击力100、血量700、防御力5、攻击速度1、移动步数1、攻击距离1
- 玩家B,棋子B属性： 攻击力80、血量500、防御力5、攻击速度1、移动步数1、攻击距离1

生成的战斗序列如下表:

| id | time | action | location | HP
| ----- | :-------- | :--------- | :------: | :------: |
|1. | 0s  |  玩家A创建棋子A  |(4,1)| 700 |
|1. | 0s  |  玩家B创建棋子B  |(4,4)| 800 |
|2. | 0s  |  棋子A 寻找目标  |(4,1)| 700 |
|2. | 0s  |  棋子B 寻找目标  |(4,4)| 800 |
|3. | 1s  |  棋子A移动       | (4,2) | 700|
|3. | 1s  |  棋子B移动       | (4,3) | 800|
|4. | 2s  |  棋子A攻击       | (4,2) | 405(95) |
|4. | 2s  |  棋子B攻击       | (4,3) | 625(75)|
|5. | 3s  |  棋子A攻击       | (4,2) | 310(95) |
|5. | 3s  |  棋子B攻击       | (4,3) | 550(75)|
|6. | 4s  |  棋子A攻击       | (4,2) | 215(95) |
|6. | 4s  |  棋子B攻击       | (4,3) | 475(75)|
|7. | 5s  |  棋子A攻击       | (4,2) | 120(95) |
|7. | 5s  |  棋子B攻击       | (4,3) | 400(75)|
|8. | 6s  |  棋子A攻击       | (4,2) | 25(95) |
|8. | 6s  |  棋子B攻击       | (4,3) | 325(75)|
|9. | 7s  |  棋子A攻击       | (4,2) | 0(95) |
|9. | 7s  |  棋子B攻击       | (4,3) | 250(75)|

[战斗序列Demo](battle/main.go)

- Demo实现流程图
![战斗序列生成流程.jpg](https://github.com/CidyChou/Markdown/blob/master/Res/%E6%88%98%E6%96%97%E5%BA%8F%E5%88%97%E7%94%9F%E6%88%90%E6%B5%81%E7%A8%8B.jpg?raw=true)

- 输出结果


      开始,玩家A [{1 700 0 1 100 5 1 1 [4 1]}]，玩家B [{2 500 0 1 80 5 1 1 [4 4]}]
      英雄1  开始移动：初始位置:[4 1] 移动后位置:[4 2]
      英雄2  开始移动：初始位置:[4 4] 移动后位置:[4 3]
      英雄1  开始攻击,原始HP:500
      英雄1  开始攻击,被攻击后HP：405
      英雄2  开始攻击,原始HP:700
      英雄2  开始攻击,被攻击后HP：625
      英雄1  开始攻击,原始HP:405
      英雄1  开始攻击,被攻击后HP：310
      英雄2  开始攻击,原始HP:625
      英雄2  开始攻击,被攻击后HP：550
      英雄1  开始攻击,原始HP:310
      英雄1  开始攻击,被攻击后HP：215
      英雄2  开始攻击,原始HP:550
      英雄2  开始攻击,被攻击后HP：475
      英雄1  开始攻击,原始HP:215
      英雄1  开始攻击,被攻击后HP：120
      英雄2  开始攻击,原始HP:475
      英雄2  开始攻击,被攻击后HP：400
      英雄1  开始攻击,原始HP:120
      英雄1  开始攻击,被攻击后HP：25
      英雄2  开始攻击,原始HP:400
      英雄2  开始攻击,被攻击后HP：325
      英雄1  开始攻击,原始HP:25
      英雄1  开始攻击,被攻击后HP：-70
      英雄2  开始攻击,原始HP:325
      英雄2  开始攻击,被攻击后HP：250
      英雄2  获胜

### 如何保证每次计算结果一致
 - 利用随机种子+初始位置坐标
    1. 客户端每次发起请求，服务端要将获取到的初始位置坐标缓存。
    2. 编写随机种子工具，在每次产生随机动作时，记录该动作的hash值，与对应的时间戳(map[string]string)。
    3. 结合初始位置坐标与随机种子即可准确地还原每一次的战斗序列。
 
